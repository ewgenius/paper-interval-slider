<link rel="import" href="../polymer/polymer.html">
<link rel="import" href="../iron-a11y-keys-behavior/iron-a11y-keys-behavior.html">
<link rel="import" href="../iron-flex-layout/iron-flex-layout.html">
<link rel="import" href="../iron-form-element-behavior/iron-form-element-behavior.html">
<link rel="import" href="../iron-interval-behavior/iron-interval-behavior.html">
<link rel="import" href="../paper-behaviors/paper-inky-focus-behavior.html">
<link rel="import" href="../paper-input/paper-input.html">
<link rel="import" href="../paper-interval-progress/paper-interval-progress.html">
<link rel="import" href="../paper-styles/color.html">
<!--
`paper-interval-slider`
A Material Design slider with two dots

@demo demo/index.html 
-->

<dom-module id="paper-interval-slider">
  <template>
    <style>
      :host {
        display: block;
      }
    </style>
    <div id="sliderContainer" class$="[[_getClassNames(disabled, pin, snaps, immediateValue, min, expand, dragging, transiting, editable)]]">
      <div class="bar-container">
        <paper-interval-progress
          disabled$="[[disabled]]"
          id="sliderBar"
          aria-hidden="true"
          min="[[min]]"
          max="[[max]]"
          step="[[step]]"
          valueFrom="[[immediateValueFrom]]"
          valueTo="[[immediateValueTo]]"
          on-down="_bardown"
          on-up="_resetKnob"
          on-track="_onTrack">
        </paper-interval-progress>
      </div>

      <template is="dom-if" if="[[snaps]]">
        <div class="slider-markers">
          <template is="dom-repeat" items="[[markers]]">
            <div class="slider-marker"></div>
          </template>
        </div>
      </template>

      <div id="sliderKnobFrom" class="slider-knob" on-down="_knobdown" on-up="_resetKnob" on-track="_onTrack" on-transitionend="_knobTransitionEnd">
        <div class="slider-knob-inner" value$="[[immediateValueFrom]]"></div>
      </div>
      <div id="sliderKnobTo" class="slider-knob" on-down="_knobdown" on-up="_resetKnob" on-track="_onTrack" on-transitionend="_knobTransitionEnd">
        <div class="slider-knob-inner" value$="[[immediateValueFrom]]"></div>
      </div>
    </div>

    <template is="dom-if" if="[[editable]]">
      <paper-input id="input" type="number" step="[[step]]" min="[[min]]" max="[[max]]" class="slider-input" disabled$="[[disabled]]"
        value="[[immediateValueFrom]]" on-change="_changeValue" on-keydown="_inputKeyDown" no-label-float>
      </paper-input>
      <paper-input id="input" type="number" step="[[step]]" min="[[min]]" max="[[max]]" class="slider-input" disabled$="[[disabled]]"
        value="[[immediateValueTo]]" on-change="_changeValue" on-keydown="_inputKeyDown" no-label-float>
      </paper-input>
    </template>
  </template>

  <script>
    Polymer({

      is: 'paper-interval-slider',

      properties: {
        /**
         * If true, the slider thumb snaps to tick marks evenly spaced based
         * on the `step` property value.
         */
        snaps: {
          type: Boolean,
          value: false,
          notify: true
        },
        /**
         * If true, a pin with numeric value label is shown when the slider thumb
         * is pressed. Use for settings for which users need to know the exact
         * value of the setting.
         */
        pin: {
          type: Boolean,
          value: false,
          notify: true
        },
        /**
         * The number that represents the current secondary progress.
         */
        secondaryProgress: {
          type: Number,
          value: 0,
          notify: true,
          observer: '_secondaryProgressChanged'
        },
        /**
         * If true, an input is shown and user can use it to set the slider value.
         */
        editable: {
          type: Boolean,
          value: false
        },
        /**
         * The immediate value of the slider.  This value is updated while the user
         * is dragging the slider.
         */
        immediateValueFrom: {
          type: Number,
          value: 0,
          readOnly: true,
          notify: true
        },
        /**
         * The immediate value of the slider.  This value is updated while the user
         * is dragging the slider.
         */
        immediateValueTo: {
          type: Number,
          value: 0,
          readOnly: true,
          notify: true
        },
        /**
         * The maximum number of markers
         */
        maxMarkers: {
          type: Number,
          value: 0,
          notify: true
        },
        /**
         * If true, the knob is expanded
         */
        expand: {
          type: Boolean,
          value: false,
          readOnly: true
        },
        /**
         * True when the user is dragging the slider.
         */
        dragging: {
          type: Boolean,
          value: false,
          readOnly: true
        },
        transiting: {
          type: Boolean,
          value: false,
          readOnly: true
        },
        markers: {
          type: Array,
          readOnly: true,
          value: []
        }
      },

      behaviors: [
        Polymer.IronA11yKeysBehavior,
        Polymer.IronFormElementBehavior,
        Polymer.PaperInkyFocusBehavior,
        Polymer.IronIntervalBehavior
      ],


      observers: [
        '_updateKnob(valueFrom, valueTo, min, max, snaps, step)',
        '_valueFromChanged(valueFrom)',
        '_valueToChanged(valueTo)',
        '_immediateValueFromChanged(immediateValueTo)',
        '_immediateValueToChanged(immediateValueFrom)',
        '_updateMarkers(maxMarkers, min, max, snaps)'
      ],

      hostAttributes: {
        role: 'slider',
        tabindex: 0
      },

      _updateKnob: function(valueFrom, valueTo, min, max, snaps, step) {
        this.setAttribute('aria-valuemin', min);
        this.setAttribute('aria-valuemax', max);
        this._positionKnobFrom(this._calcRatio(valueFrom));
        this._positionKnobTo(this._calcRatio(valueTo));
      },

      _valueFromChanged: function() {
        this.fire('value-from-change');
      },

      _valueToChanged: function() {
        this.fire('value-to-change');
      },

      _immediateValueFromChanged: function() {
        if (this.dragging) {
          this.fire('immediate-value-from-change');
        } else {
          this.valueFrom = this.immediateValueFrom;
        }
      },

      _immediateValueToChanged: function() {
        if (this.dragging) {
          this.fire('immediate-value-to-change');
        } else {
          this.valueTo = this.immediateValueTo;
        }
      },

      _secondaryProgressChanged: function() {
        this.secondaryProgress = this._clampValue(this.secondaryProgress);
      },

      _expandKnob: function() {
        this._setExpand(true);
      },

      _resetKnob: function() {
        this.cancelDebouncer('expandKnob');
        this._setExpand(false);
      },

      _positionKnobFrom: function(ratio) {
        this._setImmediateValueFrom(this._calcStep(this._calcKnobPosition(ratio)));
        this._setRatioFrom(this._calcRatio(this.immediateValueFrom));
        this.$.sliderKnobFrom.style.left = (this.ratioFrom * 100) + '%';
        if (this.dragging) {
          this._knobstartx = this.ratio * this._w;
          this.translate3d(0, 0, 0, this.$.sliderKnobFrom);
        }
      },

      _positionKnobTo: function(ratio) {
        this._setImmediateValueTo(this._calcStep(this._calcKnobPosition(ratio)));
        this._setRatioTo(this._calcRatio(this.immediateValueTo));
        this.$.sliderKnobTo.style.left = (this.ratioTo * 100) + '%';
        if (this.dragging) {
          this._knobstartx = this.ratio * this._w;
          this.translate3d(0, 0, 0, this.$.sliderKnobTo);
        }
      },

      _calcKnobPosition: function(ratio) {
        return (this.max - this.min) * ratio + this.min;
      },

      _onTrack: function(event) {
        event.stopPropagation();
        switch (event.detail.state) {
          case 'start':
            this._trackStart(event);
            break;
          case 'track':
            this._trackX(event);
            break;
          case 'end':
            this._trackEnd();
            break;
        }
      },

      _trackStart: function(event) {
        this._w = this.$.sliderBar.offsetWidth;
        this._x = this.ratio * this._w;
        this._startx = this._x;
        this._knobstartx = this._startx;
        this._minx = -this._startx;
        this._maxx = this._w - this._startx;
        this.$.sliderKnob.classList.add('dragging');
        this._setDragging(true);
      },

      _trackX: function(event) {
        if (!this.dragging) {
          this._trackStart(event);
        }
        var dx = Math.min(this._maxx, Math.max(this._minx, event.detail.dx));
        this._x = this._startx + dx;
        var immediateValue = this._calcStep(this._calcKnobPosition(this._x / this._w));
        this._setImmediateValue(immediateValue);
        // update knob's position
        var translateX = ((this._calcRatio(this.immediateValue) * this._w) - this._knobstartx);
        this.translate3d(translateX + 'px', 0, 0, this.$.sliderKnob);
      },

      _trackEnd: function() {
        var s = this.$.sliderKnob.style;
        this.$.sliderKnob.classList.remove('dragging');
        this._setDragging(false);
        this._resetKnob();
        this.value = this.immediateValue;
        s.transform = s.webkitTransform = '';
        this.fire('change');
      },

      _knobdown: function(event) {
        this._expandKnob();
        // cancel selection
        event.preventDefault();
        // set the focus manually because we will called prevent default
        this.focus();
      },

      _bardown: function(event) {
        this._w = this.$.sliderBar.offsetWidth;
        var rect = this.$.sliderBar.getBoundingClientRect();
        var ratio = (event.detail.x - rect.left) / this._w;
        var prevRatio = this.ratio;
        this._setTransiting(true);
        this._positionKnob(ratio);
        this.debounce('expandKnob', this._expandKnob, 60);
        // if the ratio doesn't change, sliderKnob's animation won't start
        // and `_knobTransitionEnd` won't be called
        // Therefore, we need to manually update the `transiting` state
        if (prevRatio === this.ratio) {
          this._setTransiting(false);
        }
        this.async(function() {
          this.fire('change');
        });
        // cancel selection
        event.preventDefault();
        // set the focus manually because we will called prevent default
        this.focus();
      },
      _knobTransitionEnd: function(event) {
        if (event.target === this.$.sliderKnob) {
          this._setTransiting(false);
        }
      },
      _updateMarkers: function(maxMarkers, min, max, snaps) {
        if (!snaps) {
          this._setMarkers([]);
        }
        var steps = Math.round((max - min) / this.step);
        if (steps > maxMarkers) {
          steps = maxMarkers;
        }
        this._setMarkers(new Array(steps));
      },
      _mergeClasses: function(classes) {
        return Object.keys(classes).filter(
          function(className) {
            return classes[className];
          }).join(' ');
      },
      _getClassNames: function() {
        return this._mergeClasses({
          disabled: this.disabled,
          pin: this.pin,
          snaps: this.snaps,
          ring: this.immediateValue <= this.min,
          expand: this.expand,
          dragging: this.dragging,
          transiting: this.transiting,
          editable: this.editable
        });
      },
      _incrementKey: function(event) {
        if (!this.disabled) {
          if (event.detail.key === 'end') {
            this.value = this.max;
          } else {
            this.increment();
          }
          this.fire('change');
        }
      },
      _decrementKey: function(event) {
        if (!this.disabled) {
          if (event.detail.key === 'home') {
            this.value = this.min;
          } else {
            this.decrement();
          }
          this.fire('change');
        }
      },
      _changeValue: function(event) {
        this.value = event.target.value;
        this.fire('change');
      },
      _inputKeyDown: function(event) {
        event.stopPropagation();
      },
      // create the element ripple inside the `sliderKnob`
      _createRipple: function() {
        this._rippleContainer = this.$.sliderKnob;
        return Polymer.PaperInkyFocusBehaviorImpl._createRipple.call(this);
      },
      // Hide the ripple when user is not interacting with keyboard.
      // This behavior is different from other ripple-y controls, but is
      // according to spec: https://www.google.com/design/spec/components/sliders.html
      _focusedChanged: function(receivedFocusFromKeyboard) {
        if (receivedFocusFromKeyboard) {
          this.ensureRipple();
        }
        if (this.hasRipple()) {
          // note, ripple must be un-hidden prior to setting `holdDown`
          if (receivedFocusFromKeyboard) {
            this._ripple.style.display = '';
          } else {
            this._ripple.style.display = 'none';
          }
          this._ripple.holdDown = receivedFocusFromKeyboard;
        }
      }
    });
  </script>
</dom-module>